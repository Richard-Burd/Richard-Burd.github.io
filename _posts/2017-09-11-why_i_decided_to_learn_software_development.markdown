---
layout: post
title:  "Why I Decided to Learn Software Development"
date:   2017-09-11 13:51:58 -0400
---


People often ask me why I decided to learn software development rather than staying in the military or returning to the practice of architecture; I would give four basic reasons for my decision, the latter three being grounded in the first:

Reason number one: I don’t think there’s a better way to make a living than designing stuff…if you’re any good at designing stuff.  During my time in the military, I kept thinking to myself how much better life would be if I could re-design this or that piece of equipment [or software] I was forced to use; most of it was low-quality, buggy, and the product of the same broken procurement process that gave us the F-35 Joint Strike Fighter fiasco.  To my peers, every problem was a ‘leadership’ problem that could be solved with better human organization; but all I saw was a need for improved equipment & software that would negate unnecessary work or headaches.  If you’re a designer at heart, all you want to do is fix things, innovate new solutions, and make life more convenient; accepting ‘as-is’ reality and bureaucratic indifference will wear you down and drive you mad. 

Reason number two: Software is the lingua franca of our modern world.  Everything runs on software, even when there’s little or no new hardware involved.  With software, you can take an existing device, such as a smartphone, and build a new app that turns that phone into a compass, calendar, or weather-forecaster.  Software allows devices on different continents to talk to each other, and even speakers of different languages to understand each other, which brings me to reason number three:

Reason number three: software is magic.  Well, at least there’s never been anything closer to the traditional definition of magic than what we have in modern software capabilities.  You can design hardware all you want but that hardware is always self-limiting.  A physical piece of something can only go so far, fly so high, or perform certain tasks.  Software can be infinitely expanded upon, upgraded to meet new demands, and run on multiple hardware platforms; you can also solve problems with software that involve little or no cost, overhead, or up-front investment.  The limitless capabilities of software are what make reason number four the reality we live in:

Reason number four: The most difficult design problems today are software problems.  A good example would be a model remote-controlled (RC) airplane.  This simple device has a battery, a radio receiver, two-to-four servo-actuator devices, an electric motor, and an airframe.  If you add a simple flight-control board into the mix, armed with a GPS, magnetometer, and a gyroscope, you can turn that simple RC airplane into a fully autonomous drone capable of carrying out a plethora of tasks.  Yet despite all the hardware that goes into these drones, the biggest chunk of time spent on problem solving involves developing all the software that runs the darn thing.  This is even truer with multi-rotor drones.  The concept of a multi-rotor aircraft has been around since the days of helicopter development, yet the problem with these aircraft was always that humans could not steer such aircraft manually.  Only after the development of flight-control software was such an aircraft made into a reality, this is because software not only makes existing hardware better and more capable, but it often defines new hardware as well.  In terms of sheer hours spent developing a new drone system, it is the software-side that usually takes the most amount of time to figure out, and is where the greatest challenges wait to be solved.

In the end, everything we touch, feel, or see is increasingly software driven, and this trend is likely to continue for a while, so that is (in a nutshell) why I decided to learn software development.

![](https://github.com/Richard-Burd/blog_graphics/blob/master/network_detail.jpg)

