I"è<p>Let‚Äôs start out by looking at a screenshot from <a href="https://www.youtube.com/watch?v=5yJ_QLec0Lc" target="_blank">Jon Krohn‚Äôs excellent video</a> on big O notation which I would recommend watching if you are totally unfamiliar with this topic:</p>

<p><img src="https://i.imgur.com/pUzkOKi.png" alt="big o notations arranged on a grid" /></p>

<p>Many lessons on big O will show something similar to this with the idea of conveying one simple truth: there exists a spectrum of big O notations that can be arranged from least efficient scaling to to most efficient scaling, and in our case above, O(n!) would scale with the least amount of efficiency while O(log n) would scale with the most efficiency.¬†  In this way, if I have two computer programming functions that do the exact same thing, and I must choose to use one of them in my software build, and all I know about these two computer programming functions is that one of them has a big O notation of O(n<sup>2</sup>) while the other has a big O notation of O(n), then I should choose to implement the one with the O(n) notation.¬†  The whole point of this article is show why that isn‚Äôt always true, and to explore how one might go about selecting the most efficient option for implementation.¬†  I will specify <em>computer programming</em> functions when discussing actual code so as not to confuse them with the <em>mathematical</em> functions we will be looking at below.¬†</p>

<p>In <em>Figure-1</em> below we have a series of functions you can view <a href="https://www.desmos.com/calculator/nuzg9tvbl9" target="_blank">here on desmos.com</a> in more detail.</p>

<p><img src="https://i.imgur.com/vKsRC9J.png" alt="figure one" />
The takeaway here is that we can observe two mathematical functions with a big O notation of <em>O(n<sup>2</sup>)</em> that scale worse than the function with a big O notation of <em>O(n!)</em>.¬†  At the same time, we can also see three mathematical functions where the opposite is true.¬†  Now to be sure, all of the <em>O(n<sup>2</sup>)</em> functions will scale better than the single <em>O(n!)</em> function <strong><em>if</em></strong> all of the the x and y values (on the grid) were to go to infinity.¬†  Now imagine two computer programming functions that followed trajectories similar to what is shown above; in such a circumstance, the computer programming function with the optimal big O notation might not be the most efficient one within the space shown.¬†</p>

<p>Now let‚Äôs consider the following python pseudocode in figure 2 below:</p>

<p><img src="https://i.imgur.com/TqDRV8i.png" alt="figure one" /></p>

<p>Here we see what can happen when conditionals are introduced; the big O of our <code class="language-plaintext highlighter-rouge">python_function()</code> is basically useless and doesn‚Äôt tell us anything about our overall performance.¬† This is because the big O here is only relevant when the input variable (x) has a value greater than or equal to 10, and is also less than 20, and yet the <code class="language-plaintext highlighter-rouge">python_function()</code> accepts values above and below that range.¬†   A rule of thumb here is that: <em>if and when a function contains conditionals that evaluate its own input variable, the big O notation of that function might not be useful for evaluating efficiency</em>.¬†  Instead, we would want to valuate the subcomponents separately</p>

<p>Now let‚Äôs take a look at a bird‚Äôs eye view of big O notation in figure 3 below:</p>

<p><img src="https://i.imgur.com/bUJoeor.png" alt="figure three" /></p>

<p>This is similar to Jon Krohn‚Äôs Microsoft-paint-sketch introduced at the beginning of this blog post, but it is a bit more comprehensive and contains more big O notations.¬†  You can view these same math functions <a href="https://www.desmos.com/calculator/wanscrgyzq">here on desmos.com</a> where you can zoom in and out to see how they better relate to each other.¬†</p>

<p>There are already several great articles describing the big O notations for various programming operations.¬†  Don Cowan has an excellent <a href="https://www.donkcowan.com/blog/2013/5/11/big-o-notation" target="_blank">summary table</a> and ≈ûahin Arslan has some great <a href="https://dev.to/humblecoder00/comprehensive-big-o-notation-guide-in-plain-english-using-javascript-3n6m" target="_blank">JavaScript example code</a>.¬†  Usman Malik has a <a href="https://stackabuse.com/big-o-notation-and-algorithm-analysis-with-python-examples/" target="_blank">similar article with Python code</a> as well.¬†  We will not repeat this material here but instead try and answer the question: <em>what if I have multiple computer programming functions that do the same thing, and I‚Äôm trying to find the one that is the most efficient, should I choose the one that has the best (i.e. most efficient) big O notation?</em>¬†  Well no, not necessary, and in fact, the big O might not help you at all.  To se what I mean let‚Äôs look at figure 4:</p>

<p><img src="https://i.imgur.com/jah11w9.png" alt="figure four" /></p>

<p>OK, so at this scale we start to see some problems.¬†  In the space shown above, the (math) functions are intersecting each other all over the place, let‚Äôs see what the implications of that are in figure 5 below:</p>

<p><img src="https://i.imgur.com/eDkEJXK.png" alt="figure five" /></p>

<p>So here we see that at this scale, different big O notations have efficiencies that are at variance with what they would be at, say, infinity.¬†  Now how would we find out the different efficiencies for multiple functions, and would we use big O?¬†  Let‚Äôs look at figure six below:</p>

<p>What the heck are we in need of a stochastic analysis for!?¬†  Let‚Äôs say we had a function to analyze different human beings based on their individual height, and that we passed these heights into a function that looks something like this:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">python_human_height_function_one</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
</code></pre></div></div>
<p>In this situation, we already know that <a href="https://ourworldindata.org/human-height#height-is-normally-distributed">human height is normally distributed</a>{target_blank}, and so if we had to choose between two functions that accomplish the calculation on a human height, but that do so using different methods, that in turn have different big O notations, we would want to know which of the two functions works best with human heights that are likely to be entered into the function.¬†  For example, I know some people are taller than 7 feet but there are very few such people, and thus, I wouldn‚Äôt choose a functions that worked fast for people above 7 feet, but worked much slower for people under 5 feet because this makes no sense.</p>

<p><img src="https://i.imgur.com/IJ4dCOk.png" alt="figure seven" /></p>

<p>So‚Ä¶</p>
:ET